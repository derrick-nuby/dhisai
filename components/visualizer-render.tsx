"use client"

import { useEffect, useRef, useState, useMemo } from "react"
import mermaid from "mermaid"
import { Download } from "lucide-react"
import { Button } from "@/components/ui/button"
import { cn } from "@/lib/utils"

interface VisualizerRenderProps {
  definition: string
  className?: string
  theme?: "default" | "forest" | "dark" | "neutral"
  backgroundColor?: string
  watermark?: string
}

export function VisualizerRender({
  definition,
  className,
  theme = "default",
  backgroundColor = "#ffffff",
  watermark = "This image was generated by Dharsi AI, a product of HISP Rwanda",
}: VisualizerRenderProps) {
  const [svg, setSvg] = useState<string>("")
  const [error, setError] = useState<string | null>(null)
  const containerRef = useRef<HTMLDivElement>(null)

  // Use useMemo to create a stable ID that doesn't change on re-renders
  const id = useMemo(() => `mermaid-${Math.random().toString(36).substring(2, 11)}`, [])

  // Track if component is mounted to prevent state updates after unmount
  const isMounted = useRef(true)

  // Initialize mermaid only once when the component mounts
  useEffect(() => {
    // Initialize mermaid configuration
    mermaid.initialize({
      startOnLoad: true,
      theme: theme,
      securityLevel: "loose",
      fontFamily: "sans-serif",
    })

    return () => {
      isMounted.current = false
    }
  }, [theme])

  // Separate useEffect for rendering the diagram
  useEffect(() => {
    const renderDiagram = async () => {
      if (!isMounted.current) return

      try {
        setError(null)
        // Use mermaidAPI directly to avoid potential issues
        const { svg } = await mermaid.render(id, definition)

        if (isMounted.current) {
          setSvg(svg)
        }
      } catch (err) {
        console.error("Mermaid rendering error:", err)
        if (isMounted.current) {
          setError("Failed to render diagram. Please check your syntax.")
        }
      }
    }

    renderDiagram()
  }, [definition, id])

  const handleDownload = () => {
    if (!svg) return

    // Fixed export dimensions
    const EXPORT_WIDTH = 1920
    const EXPORT_HEIGHT = 1080

    // Create a new SVG for export
    const parser = new DOMParser()
    const svgDoc = parser.parseFromString(svg, "image/svg+xml")
    const svgElement = svgDoc.documentElement

    // Get original viewBox if it exists
    const viewBox = svgElement.getAttribute("viewBox")
    let originalWidth, originalHeight, viewBoxWidth, viewBoxHeight

    if (viewBox) {
      const [, , vbWidth, vbHeight] = viewBox.split(" ").map(Number)
      viewBoxWidth = vbWidth
      viewBoxHeight = vbHeight
    }

    // Get original SVG dimensions
    originalWidth = Number.parseInt(svgElement.getAttribute("width") || "800", 10)
    originalHeight = Number.parseInt(svgElement.getAttribute("height") || "600", 10)

    // Use viewBox dimensions if available, otherwise use width/height
    const effectiveWidth = viewBoxWidth || originalWidth
    const effectiveHeight = viewBoxHeight || originalHeight

    // Calculate scaling to fit within 1920x1080 while maintaining aspect ratio
    const scaleX = EXPORT_WIDTH / effectiveWidth
    const scaleY = EXPORT_HEIGHT / effectiveHeight
    const scale = Math.min(scaleX, scaleY) * 0.85 // 85% to add some padding

    // Calculate dimensions after scaling
    const scaledWidth = effectiveWidth * scale
    const scaledHeight = effectiveHeight * scale

    // Calculate centering offsets
    const offsetX = (EXPORT_WIDTH - scaledWidth) / 2
    const offsetY = (EXPORT_HEIGHT - scaledHeight) / 2

    // Create offscreen canvas for high-resolution rendering
    const canvas = document.createElement("canvas")
    canvas.width = EXPORT_WIDTH
    canvas.height = EXPORT_HEIGHT
    const ctx = canvas.getContext("2d")

    if (ctx) {
      // Fill background
      ctx.fillStyle = backgroundColor
      ctx.fillRect(0, 0, EXPORT_WIDTH, EXPORT_HEIGHT)

      // Enable high-quality image rendering
      ctx.imageSmoothingEnabled = true
      ctx.imageSmoothingQuality = "high"

      // Convert SVG to image for drawing on canvas
      const img = new Image()
      img.onload = () => {
        // Draw SVG on canvas, centered and scaled
        ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight)

        // Add a subtle border around the diagram
        ctx.strokeStyle = "rgba(0,0,0,0.1)"
        ctx.lineWidth = 1
        ctx.strokeRect(offsetX - 1, offsetY - 1, scaledWidth + 2, scaledHeight + 2)

        // Add watermark text
        if (watermark) {
          ctx.font = "16px Arial, sans-serif"
          ctx.fillStyle = "#ff8000"
          ctx.textAlign = "center"
          ctx.textBaseline = "bottom"

          // Add a subtle shadow for better visibility
          ctx.shadowColor = "rgba(0,0,0,0.3)"
          ctx.shadowBlur = 3
          ctx.shadowOffsetX = 1
          ctx.shadowOffsetY = 1

          // Position at bottom center, 20px from the bottom
          ctx.fillText(watermark, EXPORT_WIDTH / 2, EXPORT_HEIGHT - 20)

          // Reset shadow
          ctx.shadowColor = "transparent"
          ctx.shadowBlur = 0
          ctx.shadowOffsetX = 0
          ctx.shadowOffsetY = 0
        }

        // Convert to PNG and download
        canvas.toBlob(
          (blob) => {
            if (blob) {
              const downloadUrl = URL.createObjectURL(blob)
              const a = document.createElement("a")
              a.href = downloadUrl
              a.download = `diagram-${new Date().toISOString().slice(0, 10)}.png`
              document.body.appendChild(a)
              a.click()
              document.body.removeChild(a)
              URL.revokeObjectURL(downloadUrl)
            }
          },
          "image/png",
          1.0,
        ) // Use maximum quality
      }

      // Convert SVG to data URL
      const serializer = new XMLSerializer()

      // Fix SVG for proper rendering
      // Ensure the SVG has proper dimensions
      if (!svgElement.hasAttribute("width")) {
        svgElement.setAttribute("width", effectiveWidth.toString())
      }
      if (!svgElement.hasAttribute("height")) {
        svgElement.setAttribute("height", effectiveHeight.toString())
      }

      // Ensure viewBox is set correctly
      if (!viewBox) {
        svgElement.setAttribute("viewBox", `0 0 ${effectiveWidth} ${effectiveHeight}`)
      }

      // Ensure preserveAspectRatio is set
      svgElement.setAttribute("preserveAspectRatio", "xMidYMid meet")

      const svgString = serializer.serializeToString(svgDoc)
      const svgBlob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" })
      const url = URL.createObjectURL(svgBlob)

      img.src = url
      img.crossOrigin = "anonymous"
    }
  }

  return (
    <div className={cn("flex flex-col space-y-4", className)}>
      <div className="relative">
        <div className="overflow-auto border rounded-md p-4 bg-white" ref={containerRef}>
          {error ? <div className="text-red-500 p-4">{error}</div> : <div dangerouslySetInnerHTML={{ __html: svg }} />}
        </div>

        <Button
          variant="outline"
          size="sm"
          className="absolute top-2 right-2"
          onClick={handleDownload}
          disabled={!svg || !!error}
        >
          <Download className="h-4 w-4 mr-2" />
          Download (1920Ã—1080)
        </Button>
      </div>
    </div>
  )
}
